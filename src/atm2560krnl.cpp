#ifndef ATM2560KRNL
#define ATM2650KRNL

#define __AVR_ATmega2560__ // only for code highlight, remove while compiling

#if defined(__AVR_ATmega2560__)

#include <Arduino.h>
#include <WString.h>
#include <stdio.h>
#include <string.h>

#include "ntskrnl.hpp"

#define ABOUT (cseq) "NoteOS 8-bit v1.0 , Arch: (ATMega2560), 2022"

#include "drivers/graphic/sh1106_driver.hpp"

#define MAX_DRIVER_ABOUT_NAME 64
#define IDVC_DRIVER_MAX_REGISTRY_SIZE 32
#define IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE UINT8

#define IDVCREGISTRY_OUT_OF_MEMORY          0x01
#define IDVCREGISTRY_DRIVER_REGISTRY_FULL   0x02
#define IDVCREGISTRY_NO_DRIVER              0x03

const UINT8 epd_bitmap_noteos [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc3, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc1, 0xf1, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc1, 0xf1, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xc0, 0xf1, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xc0, 0xf1, 0xf8, 0x1f, 0x00, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xc6, 0x71, 0xf3, 0x8f, 0x8f, 0xf3, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xc6, 0x71, 0xe3, 0xc7, 0x8f, 0xe7, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xc7, 0x31, 0xc7, 0xc7, 0x8f, 0xc3, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xc7, 0x31, 0xc7, 0xe7, 0x8f, 0xc0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 
	0xff, 0xc7, 0x81, 0xc7, 0xe7, 0x8f, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 
	0xff, 0xc7, 0x81, 0xe7, 0xc7, 0x8f, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 
	0xff, 0xc7, 0xc1, 0xe3, 0xc7, 0x8f, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 
	0xff, 0xc7, 0xc1, 0xf1, 0x8f, 0xc7, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 
	0xff, 0xc7, 0xe3, 0xfc, 0x3f, 0xe1, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x7f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x60, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x78, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7c, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7e, 0x0f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7e, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x1f, 0xff, 
	0xff, 0xff, 0xff, 0xe0, 0x3f, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0xcf, 0x9f, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x3f, 0xff, 
	0xff, 0xff, 0xff, 0x8f, 0x8f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x7f, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0x7f, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x1f, 0xc3, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xfe, 0x1f, 0xc3, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x1f, 0xc7, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x8f, 0x8f, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xc7, 0x1f, 0x9e, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0x7f, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0c, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x01, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

IDVCHIDriver_Dsply* selected_graphic = NULL;

BOOLN is_logging_to_graphic = false;

struct idvc_device {
    idvc_id id;
    IDVCHIDriver* drvr;
};


class IDVC_Registry {
    private:
        struct idvc_device *registry = NULL;
        IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE index = -1;
        size_t used_size = 0;

    public:
        IDVC_Registry(){
            used_size = sizeof(struct idvc_device);
            registry = (struct idvc_device*) malloc(used_size);
        }

        ERR add_dvc(IDVCHIDriver* drvr, idvc_id id){
            used_size = sizeof(struct idvc_device) * ++index + 1;
            registry = (struct idvc_device*) realloc(registry, used_size);
            if(registry == NULL){
                NTSKernel::nt_log(("[IDVCRegistry]: Driver registry is out of memory. Operation cancelled."), CRIT);
                return IDVCREGISTRY_OUT_OF_MEMORY;
            }
            registry[index] = (struct idvc_device){id, drvr};

            UINT16 drvr_name = strlen(drvr -> drvr_name().c_str());
            if(drvr_name > MAX_DRIVER_ABOUT_NAME){
                drvr_name = MAX_DRIVER_ABOUT_NAME;
            }

            cseq msg = "[IDVCRegistry]: Driver [" + drvr -> drvr_name() + "] has been added to registry.";
            NTSKernel::nt_log(msg, INFO);

            return OK;
        }

        ERR get_dvc(idvc_id id, IDVCHIDriver** source_drvr){

            for(int i = 0; i < index + 1; i++){
                struct idvc_device drvr = registry[i];
                if(drvr.id == id){
                    *source_drvr = drvr.drvr;
                    return OK;
                }
            }

            return IDVCREGISTRY_NO_DRIVER;
        }

        ERR get_dvcs(struct idvc_device** driver, IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE *__size){
            if(registry == NULL){
                NTSKernel::nt_log(("[IDVCRegistry] Driver register is empty or not allocated yet."), WARN);
                return IDVCREGISTRY_NO_DRIVER;
                *driver = NULL;
            }
            *driver = registry;
            *__size = get_drivers_count();
            return OK;
        }
        
        size_t get_used_space(){
            return used_size;
        }

        IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE get_drivers_count(){
            return index + 1;
        }
};


IDVC_Registry *idvc_registry = NULL;

struct umsb_device {

};


VOID init_drivers(){
    NTSKernel::nt_log("[NTSKernel] Initializing drivers.", INFO);

    SH1106OLEDDriver* scrn_drvr = new SH1106OLEDDriver; 
    NTSKernel::nt_load_idvc_drvr(scrn_drvr, IDVC_DISPLAY);
}

String make_hex(UINT32 dec){
    String hex = String(dec, HEX);
    hex.toUpperCase();
    return "0x" + hex;
}

VOID start_drivers(){
    struct idvc_device* drivers;
    IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE size;

    ERR err = idvc_registry -> get_dvcs(&drivers, &size);
    if(err == OK){
        for(IDVC_DRIVER_REGISTRY_SIZE_DATA_TYPE i = 0; i < size; i++){
            struct idvc_device device = drivers[i];
            IDVCHIDriver* driver = device.drvr;
            cseq device_hex = make_hex(device.id);
            cseq msg = "[IDVCDriverBus] Starting [" + device_hex + "] device with [" + String(driver -> drvr_name()) + "] driver.";
            cseq msg2 = "[IDVCDriverBus] Device [" + device_hex + "] use transport [" + make_hex(driver -> get_trnsprt()) + "]";
            NTSKernel::nt_log(msg, INFO);
            NTSKernel::nt_log(msg2, INFO);

            driver -> begin_device();
            if(!driver -> available()){
                String msg3 = "[IDVCDriverBus] At the moment device [" + device_hex + "] is unavailable";
                NTSKernel::nt_log((msg3.c_str()), INFO);
            }
        }
    }else {
        String msg = "[IDVCDriverBus] Cannot fetch drivers for start sequence due error: [" + make_hex(err)  + "]";
        NTSKernel::nt_log((msg.c_str()), ERROR);
    }
}

VOID init_graphic(){    
    IDVCHIDriver* drvr;
    IDVCHIDriver_Dsply* display;
    if(NTSKernel::nt_get_idvc_drvr(&drvr, IDVC_DISPLAY) != OK){
        NTSKernel::nt_log(("[NTSKernel] Graphic not found in current environment."), INFO);
        return;
    }
    
    display = reinterpret_cast<IDVCHIDriver_Dsply*>(drvr);
    
    if(display -> available()){
        display -> clr_scrn();
        selected_graphic = display;
        String msg = "[NTSKernel] Graphics device [" + String(display -> drvr_name()) + "] is selected as primary monitor.";
        NTSKernel::nt_log(msg, INFO);
        display -> render_bitmap(0, 0, epd_bitmap_noteos, 128, 64, WHITE);
        
    }else {
        NTSKernel::nt_log(("[NTSKernel] Graphics is found but display device is unreachable at the moment."), INFO);
    }
}

BOOLN is_booted = false;

cseq translate_loglevel(LOG_LEVEL level){
    if(level == INFO){
        return (cseq) "INFO";
    }else if(level == WARN){
        return (cseq) "WARN";
    }else if(level ==  CRIT){
        return (cseq) "CRIT";
    }else if(level == TRACE){
        return (cseq) "TRACE";
    }else if(level == DEBUG){
        return (cseq) "DEBUG";
    }else if(level == CRIT){
        return (cseq) "CRIT";
    }else if(level == PANIC){
        return (cseq) "PANIC";
    }else {
        return (cseq) "nolevel";
    }
}

VOID NTSKRNL NTSKernel::nt_log(const cseq msg, LOG_LEVEL level){
    cseq level_str = translate_loglevel(level);
    if(strcmp(level_str.c_str(), "nolevel") != 0){
        Serial.print("[");
        Serial.print(String(millis(), DEC));
        Serial.print("] [");
        Serial.print(level_str);
        Serial.print("]: ");
        Serial.print(msg);
        Serial.print("\n");
        Serial.flush();  
    }

    if(selected_graphic != NULL && is_logging_to_graphic){
        selected_graphic -> print(String(msg));
    }

}

VOID NTSKRNL NTSKernel::nt_boot_sequence(VOID) {
    if(is_booted){
        nt_log(("Boot sequence request while system running."), WARN);    
    }

    delay(2000);
    Serial.begin(9600);

    String msg PROGMEM = "Booting: " + ABOUT;
    nt_log(msg, INFO);


    init_drivers();

    start_drivers();

    nt_log(("[NTSKernel] Loading graphics."), INFO);
    init_graphic();

    is_booted = true;
}

VOID NTSKRNL NTSKernel::nt_srl_trnmt(const cseq data){

}


ERR NTSKRNL NTSKernel::nt_load_idvc_drvr(IDVCHIDriver* drvr, idvc_id id)
{
    if(idvc_registry == NULL){
        idvc_registry = new IDVC_Registry;
    }

    idvc_registry -> add_dvc(drvr, id);
    return OK;
}

VOID NTSKRNL NTSKernel::nt_cls_krnl_sequence(){
    if(is_booted){
        nt_log(("[NTSKernel]: Shutting down kernel."), INFO);

        delete idvc_registry;
    }else {
        nt_log(("[NTSKernel]: Requested kernel close operation but system is not already booted."), ERROR);
    }
}

UINT32 NTSKRNL NTSKernel::nt_get_free_sram(){
    extern int __heap_start, *__brkval;
	int v;
	return (int)&v - (__brkval == 0 ? (int)&__heap_start : (int)__brkval);
}

VOID NTSKRNL NTSKernel::nt_mem_free(void* ptr){
    if(ptr != NULL){
        free(ptr);
        ptr = 0;
    }else {
        char buf[128];
        sprintf(buf, "[NTSKernel]: Pointer at %p cannot be released because address is already 0.", &ptr);
        nt_log(buf, ERROR);
    }
}

cseq NTSKRNL NTSKernel::nt_about(){
    return ABOUT;
}

ERR NTSKRNL NTSKernel::nt_get_dsply(IDVCHIDriver_Dsply** driver){
    *driver = selected_graphic;
    return OK;
}

ERR NTSKRNL NTSKernel::nt_get_idvc_drvr(IDVCHIDriver** drvr, idvc_id id){
    ERR err = idvc_registry->get_dvc(id, drvr);
    if(err != OK){
        String msg = "Driver [" + make_hex(id) + "] is cannot be get from registry due: [" + make_hex(err) + "]";
        nt_log((msg.c_str()), WARN);
        *drvr = NULL;
        return err;
    }

    return OK;
}

VOID NTSKRNL nt_set_logging_to_graphic(BOOLN is_logging){
    is_logging_to_graphic = is_logging;
}


#endif

#endif